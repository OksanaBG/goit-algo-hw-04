# Порівняння алгоритмів сортування

## Мета
Емпірично порівняти час виконання трьох алгоритмів сортування — **Insertion Sort**, **Merge Sort** та **Timsort** (вбудовані `sorted()` і `list.sort()` у Python). Додатково включено **Bubble Sort** як базовий O(n²) приклад. Мета — підтвердити теоретичні оцінки складності та зробити висновки щодо практичного вибору алгоритму.

## Коротко про алгоритми
- **Insertion Sort** — O(n²), простий, ефективний лише на малих масивах або майже відсортованих даних.
- **Merge Sort** — O(n log n), стабільний за складністю, підходить для великих масивів.
- **Timsort** (`sorted()` / `.sort()`) — гібрид з ідей merge + insertion, оптимізує вже впорядковані підпослідовності (*runs*). У Python реалізований на C, тож має низькі константи часу.
- **Bubble Sort** — O(n²), навчальний приклад, практично не використовується.

## Методика експерименту
- Дані: випадкові цілі числа з діапазону відповідного розміру набору.
- Розміри наборів: `10`, `100`, `1000`, `10000` елементів.
- Вимірювання: функція `timeit.default_timer()`, кілька повторів з усередненням; коректність перевірялася порівнянням з еталоном `sorted(data)`.
- Для `.sort()` використано обгортку, що працює з копією списку, щоб інтерфейс був одинковий для всіх функцій.

## Результати (за моїм запуском)
```
dataset          algo                  mean (ms)      stdev
------------------------------------------------------------
smallest(10)     Insertion                  0.00       0.00
smallest(10)     Merge                      0.01       0.00
smallest(10)     Timsort(sorted)            0.00       0.00
smallest(10)     Timsort(.sort)             0.00       0.00
smallest(10)     Bubble                     0.01       0.01
small(100)       Insertion                  0.11       0.02
small(100)       Merge                      0.09       0.02
small(100)       Timsort(sorted)            0.01       0.01
small(100)       Timsort(.sort)             0.00       0.00
small(100)       Bubble                     0.22       0.02
big(1000)        Insertion                 11.95       1.35
big(1000)        Merge                      0.98       0.03
big(1000)        Timsort(sorted)            0.09       0.03
big(1000)        Timsort(.sort)             0.07       0.03
big(1000)        Bubble                    25.14       1.34
largest(10000)   Insertion               1174.74      14.85
largest(10000)   Merge                     13.17       0.39
largest(10000)   Timsort(sorted)            0.90       0.09
largest(10000)   Timsort(.sort)             1.07       0.23
```

## Аналіз
- На **малих наборах (10–100)** всі алгоритми дуже швидкі, але вже видно, що **Timsort** має найменший час; **Bubble** та **Insertion** починають відставати.
- На **1000 елементів** різниця стає очевидною:  
  - **Timsort**: ~0.07–0.09 ms  
  - **Merge**: ~0.98 ms  
  - **Insertion**: ~11.95 ms  
  - **Bubble**: ~25.14 ms  
  → порядок переваги відповідає теорії (O(n log n) та C-оптимізації Timsort проти O(n²)).
- На **10000 елементів**:  
  - **Timsort**: ~0.90–1.07 ms  
  - **Merge**: ~13.17 ms  
  - **Insertion**: ~1174.74 ms  
  → **Timsort** суттєво швидший за чистий Python-**Merge Sort** та на порядки швидший за **Insertion/Bubble**.

## Висновки (для цього випадку)
1. **Timsort (`sorted()`/`.sort()`) — найкращий вибір у Python**: стабільно найшвидший на всіх перевірених наборах; особливо ефективний на частково відсортованих даних.
2. **Merge Sort** показує очікуване O(n log n) масштабування, але програє Timsort через вищі константи часу в чистій Python-реалізації.
3. **Insertion Sort** доцільний тільки для дуже малих масивів або як частина гібридів (як у Timsort).
4. **Bubble Sort** — непридатний для великих даних; вартий лише для навчальних демонстрацій.

> Підсумок: поєднання злиття й вставок у **Timsort** та оптимізована реалізація на C пояснюють, чому в реальних задачах розумніше використовувати вбудовані сортування Python, а не писати власні.

## Як відтворити
1. Згенерувати випадкові масиви для розмірів 10/100/1000/10000.  
2. Для кожного алгоритму запустити кілька повторів, взяти середній час (`timeit.default_timer`).  
3. Перевірити коректність сортування через `assert out == sorted(data)`.  
4. (Опційно) Побудувати графіки часу vs розмір масиву для візуалізації масштабування.
